<!DOCTYPE html>
<!--
 | Hybrid navigation (SbUiNavigation) demo web page.
 |
 | This demonstrates basic use of focus items and scroll containers. On
 | platforms which implement SbUiNavGetInterface, the user can change focus
 | with a platform-appropriate input device.
 |
 | HTMLElements using "overflow: auto" or "overflow: scroll" are treated as
 | scroll containers.
 |
 | HTMLElements with "tabindex" <= -2 are treated as focus items.
 |
 | "-cobalt-ui-nav-focus-transform()" is a Cobalt-specific transform function
 | for hybrid navigation which tracks interaction with the navigation item when
 | it is focused. This function queries the closest hybrid navigation focus item
 | (i.e. this element or an ancestor element with tabindex set appropriately).
 | If that navigation item does not have focus, or the system does not provide
 | interaction animations, then this transform function will evaluate to
 | identity. If no ancestor is a hybrid navigation focus item, then the
 | currently-focused item (which may be in a different subtree) is used.
 |
 | "-cobalt-ui-nav-spotlight-transform()" is a Cobalt-specific transform
 | function for hybrid navigation which tracks the direction in which focus is
 | moving. This can be used to provide feedback about user input that is too
 | small to result in a focus change. The transform function queries the closest
 | hybrid navigation focus item (i.e. this element or an ancestor element with
 | tabindex set appropriately). If the closest hybrid navigation focus item does
 | not have focus, or the platform does not provide focus movement information,
 | then this transform function will evaluate to the zero scale. Otherwise the
 | transform will evaluate to a translation ranging from -50% to +50% in the X
 | and Y directions. If no ancestor is a hybrid navigation focus item, then the
 | currently-focused item (which may be in a different subtree) is queried.
 -->
<html>
  <head>
    <style>
      body {
        background-color: rgb(25,25,25);
        color: rgb(200,200,200);
        width: 1280px;
        height: 720px;
      }

      .vscroll {
        overflow: auto;
        position: absolute;
        transform: translate(100px,100px);
        background-color: rgb(50,50,50);
        width: 1080px;
        height: 520px;
      }

      .hscroll {
        overflow: auto;
        position: relative;
        background-color: rgb(75, 75, 75);
        /*
         * Leave a slight margin on the right for vscroll's scrollbar (only
         * needed for non-Cobalt browsers). Cobalt does not show scrollbars,
         * so this can be the same width as vscroll.
         */
        width: 1060px;
        /*
         * Also make the height big enough to show a horizontal scrollbar
         * (for non-Cobalt browsers) in addition to the contents.
         */
        height: 320px;
      }

      /*
       * focusItem is used as the actual focusable item. Its dimensions are
       * static so that the underlying SbUiNavigation system knows how much to
       * scroll to ensure it is fully visible. The scroll animation is usually
       * calculated to bring the to-be-focused item into view, but if that item
       * is resized after the animation starts, then the animation may no
       * longer end with the larger item in full view.
       */
      .focusItem {
        overflow: hidden;
        position: absolute;
        width: 300px;
        height: 300px;
        outline: none;
      }

      /*
       * focusContent will react to focus changes. Its size will grow when
       * its parent receives focus.
       */
      .focusContent {
        overflow: hidden;
        margin: 20px;
        border: 5px solid rgb(0,0,0);
        width: 250px;
        height: 250px;
        line-height: 250px;
        text-align: center;
        vertical-align: middle;
        font-size: 100px;

        /*
         * The user may be scrolling through items quickly. Use a transition
         * delay so that the transition is shown once the user settles on a
         * focus item.
         */
        transition: transform 0.5s;
        transition-delay: 0.1s;
      }

      /*
       * Update focusContent when the parent is focused.
       */
      .focusItem:focus .focusContent {
        background-color: rgb(240,240,240);
        color: rgb(0,0,0);
        transform: -cobalt-ui-nav-focus-transform() scale(1.1);
      }

      /*
       * Add a spotlight to focusContent when the parent is focused.
       */
      .focusItem:focus .focusContent::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(rgba(255,0,0,0.5) 0%, rgba(255,0,0,0) 30%);
        transform: -cobalt-ui-nav-spotlight-transform();
      }
    </style>
  </head>

  <body class="body">
    <div class="vscroll">
      <div class="hscroll">
        <div id="start" class="focusItem" tabindex="-1" style="transform: translateX(0px)">
          <div class="focusContent">A0</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(300px)">
          <div class="focusContent">A1</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(600px)">
          <div class="focusContent">A2</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(900px)">
          <div class="focusContent">A3</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(1200px)">
          <div class="focusContent">A4</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(1500px)">
          <div class="focusContent">A5</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(1800px)">
          <div class="focusContent">A6</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(2100px)">
          <div class="focusContent">A7</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(2400px)">
          <div class="focusContent">A8</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(2700px)">
          <div class="focusContent">A9</div>
        </div>
      </div>
      <div class="hscroll">
        <div class="focusItem" tabindex="-1" style="transform: translateX(0px)">
          <div class="focusContent">B0</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(300px)">
          <div class="focusContent">B1</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(600px)">
          <div class="focusContent">B2</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(900px)">
          <div class="focusContent">B3</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(1200px)">
          <div class="focusContent">B4</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(1500px)">
          <div class="focusContent">B5</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(1800px)">
          <div class="focusContent">B6</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(2100px)">
          <div class="focusContent">B7</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(2400px)">
          <div class="focusContent">B8</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(2700px)">
          <div class="focusContent">B9</div>
        </div>
      </div>
      <div class="hscroll">
        <div class="focusItem" tabindex="-1" style="transform: translateX(0px)">
          <div class="focusContent">C0</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(300px)">
          <div class="focusContent">C1</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(600px)">
          <div class="focusContent">C2</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(900px)">
          <div class="focusContent">C3</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(1200px)">
          <div class="focusContent">C4</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(1500px)">
          <div class="focusContent">C5</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(1800px)">
          <div class="focusContent">C6</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(2100px)">
          <div class="focusContent">C7</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(2400px)">
          <div class="focusContent">C8</div>
        </div>
        <div class="focusItem" tabindex="-1" style="transform: translateX(2700px)">
          <div class="focusContent">C9</div>
        </div>
      </div>
    </div>
  </body>
  <script>
window.onload = function() {
  document.getElementById("start").focus();
};

const jogEvents = [
  [-0.07598876953125,-0.826507568359375],
  [-0.096893310546875,-0.7825927734375],
  [-0.078094482421875,-0.7825927734375],
  [-0.0509033203125,-0.7825927734375],
  [-0.013275146484375,-0.7825927734375],
  [0.066162109375,-0.770050048828125],
  [0.10797119140625,-0.770050048828125],
  [0.153961181640625,-0.75543212890625],
  [0.218780517578125,-0.734527587890625],
  [0.268951416015625,-0.703155517578125],
  [0.30657958984375,-0.694793701171875],
  [0.354644775390625,-0.667633056640625],
  [0.402740478515625,-0.63836669921875],
  [0.446624755859375,-0.609100341796875],
  [0.486358642578125,-0.577728271484375],
  [0.555328369140625,-0.50872802734375],
  [0.584625244140625,-0.469024658203125],
  [0.6138916015625,-0.42510986328125],
  [0.64105224609375,-0.379119873046875],
  [0.668243408203125,-0.3310546875],
  [0.701690673828125,-0.24114990234375],
  [0.720489501953125,-0.205596923828125],
  [0.743499755859375,-0.103179931640625],
  [0.75811767578125,0.0159912109375],
  [0.760223388671875,0.072418212890625],
  [0.760223388671875,0.179046630859375],
  [0.75811767578125,0.3170166015625],
  [0.737213134765625,0.35882568359375],
  [0.710052490234375,0.400634765625],
  [0.653594970703125,0.480072021484375],
  [0.58880615234375,0.553253173828125],
  [0.5511474609375,0.586700439453125],
  [0.511444091796875,0.62432861328125],
  [0.454986572265625,0.670318603515625],
  [0.404815673828125,0.70794677734375],
  [0.25640869140625,0.783203125],
  [0.204132080078125,0.802032470703125],
  [0.17486572265625,0.810394287109375],
  [0.064056396484375,0.829193115234375],
  [-0.061370849609375,0.835479736328125],
  [-0.26416015625,0.795745849609375],
  [-0.312225341796875,0.779022216796875],
  [-0.37286376953125,0.75811767578125],
  [-0.452301025390625,0.726776123046875],
  [-0.512908935546875,0.6995849609375],
  [-0.563079833984375,0.6661376953125],
  [-0.627899169921875,0.584625244140625],
  [-0.6634521484375,0.530242919921875],
  [-0.684356689453125,0.4989013671875],
  [-0.75750732421875,0.34002685546875],
  [-0.77215576171875,0.29193115234375],
  [-0.79095458984375,0.229217529296875],
  [-0.80560302734375,0.103790283203125],
  [-0.80560302734375,0.053619384765625],
  [-0.80560302734375,0.01806640625],
  [-0.80560302734375,-0.046722412109375],
  [-0.80560302734375,-0.080169677734375],
  [-0.80560302734375,-0.10736083984375],
  [-0.80560302734375,-0.1826171875],
  [-0.80560302734375,-0.216064453125],
  [-0.80560302734375,-0.24951171875],
  [-0.78887939453125,-0.318511962890625],
  [-0.744964599609375,-0.410491943359375],
  [-0.7156982421875,-0.45855712890625],
  [-0.65509033203125,-0.53173828125],
  [-0.636260986328125,-0.552642822265625],
  [-0.60699462890625,-0.579803466796875],
  [-0.554718017578125,-0.625823974609375],
  [-0.502471923828125,-0.661346435546875],
  [-0.4815673828125,-0.67181396484375],
  [-0.4501953125,-0.686431884765625],
  [-0.435577392578125,-0.68853759765625],
  [-0.4146728515625,-0.694793701171875],
  [-0.349853515625,-0.7303466796875],
  [-0.268341064453125,-0.7303466796875],
  [-0.22442626953125,-0.7303466796875],
  [-0.180511474609375,-0.7303466796875],
  [-0.11572265625,-0.7303466796875],
  [-0.055084228515625,-0.7303466796875],
  [-0.0341796875,-0.7303466796875],
  [-0.0174560546875,-0.7303466796875],
  [0.04107666015625,-0.7303466796875],
  [0.053619384765625,-0.7303466796875],
  [0.064056396484375,-0.726165771484375],
  [0.07659912109375,-0.72198486328125],
  [0.080780029296875,-0.717803955078125],
  [0.0849609375,-0.713623046875],
  [0.0849609375,-0.709442138671875],
  [0.0849609375,-0.703155517578125],
  [0.0849609375,-0.6968994140625],
  [0.0849609375,-0.69061279296875],
  [0.0849609375,-0.692718505859375],
];

let swipeEvents = []
const swipeVerticalEndToEnd = [
  [0.053619384765625,-0.8975830078125],
  [-0.015380859375,-0.851593017578125],
  [-0.021636962890625,-0.83905029296875],
  [-0.021636962890625,-0.828582763671875],
  [-0.021636962890625,-0.818145751953125],
  [-0.02374267578125,-0.80767822265625],
  [-0.0321044921875,-0.759613037109375],
  [-0.0341796875,-0.709442138671875],
  [-0.036285400390625,-0.692718505859375],
  [-0.038360595703125,-0.67388916015625],
  [-0.04046630859375,-0.642547607421875],
  [-0.04046630859375,-0.62371826171875],
  [-0.04254150390625,-0.604888916015625],
  [-0.04254150390625,-0.577728271484375],
  [-0.04254150390625,-0.563079833984375],
  [-0.04254150390625,-0.51708984375],
  [-0.04254150390625,-0.494110107421875],
  [-0.04254150390625,-0.446014404296875],
  [-0.04254150390625,-0.393768310546875],
  [-0.04254150390625,-0.368682861328125],
  [-0.04254150390625,-0.345672607421875],
  [-0.04254150390625,-0.32269287109375],
  [-0.04254150390625,-0.278778076171875],
  [-0.04254150390625,-0.2327880859375],
  [-0.04254150390625,-0.20977783203125],
  [-0.04254150390625,-0.188873291015625],
  [-0.04254150390625,-0.172149658203125],
  [-0.04254150390625,-0.134521484375],
  [-0.04254150390625,-0.11572265625],
  [-0.04254150390625,-0.05718994140625],
  [-0.038360595703125,-0.00909423828125],
  [-0.036285400390625,0.00762939453125],
  [-0.0321044921875,0.05987548828125],
  [-0.029998779296875,0.087066650390625],
  [-0.027923583984375,0.114227294921875],
  [-0.02581787109375,0.14141845703125],
  [-0.019561767578125,0.193695068359375],
  [-0.0174560546875,0.2166748046875],
  [-0.015380859375,0.24176025390625],
  [-0.013275146484375,0.266845703125],
  [-0.011199951171875,0.3316650390625],
  [-0.011199951171875,0.3671875],
  [-0.011199951171875,0.402740478515625],
  [-0.011199951171875,0.477996826171875],
  [-0.011199951171875,0.4989013671875],
  [-0.011199951171875,0.563690185546875],
  [-0.011199951171875,0.62225341796875],
  [-0.011199951171875,0.63897705078125],
  [-0.011199951171875,0.6995849609375],
  [-0.011199951171875,0.726776123046875],
  [-0.011199951171875,0.745574951171875],
  [-0.011199951171875,0.831298828125],
  [-0.011199951171875,0.8480224609375],
  [-0.00909423828125,0.88983154296875],
  [0.0013427734375,0.9169921875],
  [0.005523681640625,0.92535400390625],
  [0.00762939453125,0.9337158203125],
  [0.00970458984375,0.937896728515625],
];

const swipeHorizontalEndToEnd = [[-0.899658203125,0.011810302734375],
[-0.899658203125,0.011810302734375],
[-0.862030029296875,0.05780029296875],
[-0.859954833984375,0.05987548828125],
[-0.853668212890625,0.0682373046875],
[-0.84112548828125,0.078704833984375],
[-0.82440185546875,0.0849609375],
[-0.751251220703125,0.089141845703125],
[-0.7156982421875,0.089141845703125],
[-0.642547607421875,0.089141845703125],
[-0.537994384765625,0.089141845703125],
[-0.446014404296875,0.089141845703125],
[-0.404205322265625,0.089141845703125],
[-0.379119873046875,0.089141845703125],
[-0.303863525390625,0.089141845703125],
[-0.27252197265625,0.089141845703125],
[-0.17633056640625,0.089141845703125],
[-0.130340576171875,0.089141845703125],
[-0.096893310546875,0.089141845703125],
[-0.07598876953125,0.089141845703125],
[-0.0174560546875,0.089141845703125],
[0.0347900390625,0.089141845703125],
[0.1016845703125,0.089141845703125],
[0.1351318359375,0.089141845703125],
[0.287750244140625,0.089141845703125],
[0.31494140625,0.089141845703125],
[0.3839111328125,0.09124755859375],
[0.421539306640625,0.09332275390625],
[0.452911376953125,0.095428466796875],
[0.553253173828125,0.099609375],
[0.57623291015625,0.12469482421875],
[0.6494140625,0.128875732421875],
[0.6640625,0.128875732421875],
[0.687042236328125,0.128875732421875],
[0.7330322265625,0.128875732421875],
[0.762298583984375,0.128875732421875],
[0.818756103515625,0.114227294921875],
[0.83966064453125,0.114227294921875],
[0.85845947265625,0.114227294921875],
[0.887725830078125,0.114227294921875],
[0.910736083984375,0.114227294921875],
[0.9169921875,0.114227294921875],
[0.92535400390625,0.114227294921875],
[0.929534912109375,0.114227294921875],
[0.931640625,0.114227294921875]]

const swipeHorizontalMiddleToEnd = [[0.053619384765625,0.193695068359375],
[0.047332763671875,0.1978759765625],
[0.09332275390625,0.193695068359375],
[0.130950927734375,0.193695068359375],
[0.27313232421875,0.193695068359375],
[0.3504638671875,0.193695068359375],
[0.454986572265625,0.193695068359375],
[0.513519287109375,0.193695068359375],
[0.595062255859375,0.185333251953125],
[0.630615234375,0.172760009765625],
[0.74139404296875,0.130950927734375],
[0.80621337890625,0.097503662109375],
[0.835479736328125,0.080780029296875],
[0.85845947265625,0.064056396484375],]

const swipeVerticalMiddleToEnd = [[-0.071807861328125,0.045257568359375],
[-0.038360595703125,0.118408203125],
[-0.038360595703125,0.128875732421875],
[-0.038360595703125,0.1351318359375],
[-0.038360595703125,0.14349365234375],
[-0.038360595703125,0.147674560546875],
[-0.038360595703125,0.156036376953125],
[-0.038360595703125,0.164398193359375],
[-0.038360595703125,0.170684814453125],
[-0.038360595703125,0.181121826171875],
[-0.038360595703125,0.212493896484375],
[-0.038360595703125,0.262664794921875],
[-0.038360595703125,0.3818359375],
[-0.038360595703125,0.40692138671875],
[-0.038360595703125,0.477996826171875],
[-0.038360595703125,0.572052001953125],
[-0.038360595703125,0.620147705078125],
[-0.038360595703125,0.712127685546875],
[-0.038360595703125,0.73931884765625],
[-0.027923583984375,0.810394287109375],
[-0.021636962890625,0.837554931640625],
[-0.015380859375,0.862640380859375],
[-0.011199951171875,0.885650634765625],
[-0.004913330078125,0.9149169921875],
[-0.002838134765625,0.92327880859375],]

const getElementToRight = el => {
  return el.nextElementSibling;
};

const getElementToLeft = el => {
  return el.previousElementSibling;
};

const getElementAbove = el => {
  const refPosition = el.getBoundingClientRect().left;
  const parent = el.parentElement;
  if (parent && parent.previousElementSibling) {
    let prev = null;
    let prevRect = null;
    let next = parent.previousElementSibling.firstElementChild;
    while (next !== null) {
      const rect = next.getBoundingClientRect();
      if (rect.left >= refPosition) {
        if (rect.right > next.parentElement.clientWidth + 108) {
          return prev;
        }
        if (prevRect && Math.abs(refPosition - prevRect.left) < Math.abs(refPosition - rect.left)) {
          return prev;
        }
        return next;
      }
      if (!next.nextElementSibling) {
        return next;
      }
      prev = next;
      prevRect = rect;
      next = next.nextElementSibling;
    }
  }
  return null;
};

const getElementBelow = el => {
  const refPosition = el.getBoundingClientRect().left;
  const parent = el.parentElement;
  if (parent && parent.nextElementSibling) {
    let prev = null;
    let prevRect = null;
    let next = parent.nextElementSibling.firstElementChild;
    while (next !== null) {
      const rect = next.getBoundingClientRect();
      if (rect.left >= refPosition) {
        if (rect.right > next.parentElement.clientWidth + 108) {
          return prev;
        }
        if (prevRect && Math.abs(refPosition - prevRect.left) < Math.abs(refPosition - rect.left)) {
          return prev;
        }
        return next;
      }
      if (!next.nextElementSibling) {
        return next;
      }
      prev = next;
      prevRect = rect;
      next = next.nextElementSibling;
    }
  }
  return null;
};

// cancel only animations for target scroll container
let animationId = 0;
const animations = {};
const now = () => new Date().getTime();
const updateTargetScrollLeft = (el, toScrollLeft, lengthMs) => {
  Object.keys(animations).forEach(k => {
    animations[k] = false;
  });
  animationId++;
  if (animationId > 1000) {
    animationId = 0;
  }
  const currentId = animationId;
  animations[currentId] = true;
  const startLocation = el.scrollLeft;
  const diff = Math.abs(toScrollLeft - el.scrollLeft);
  const forward = toScrollLeft > el.scrollLeft;
  start = now();
  const update = () => {
    if (!animations[currentId]) {
      delete animations[currentId];
      return;
    }
    const t = now();
    const offset = diff * Math.min(1, (t - start) / lengthMs);
    if (forward) {
      el.scrollLeft = startLocation + offset;
    } else {
      el.scrollLeft = startLocation - offset;
    }
    if (t - start < lengthMs) {
      requestAnimationFrame(update);
    }
  };
  requestAnimationFrame(update);
};

const updateTargetScrollTop = (el, toScrollTop, lengthMs) => {
  Object.keys(animations).forEach(k => {
    animations[k] = false;
  });
  animationId++;
  if (animationId > 1000) {
    animationId = 0;
  }
  const currentId = animationId;
  animations[currentId] = true;
  const startLocation = el.scrollTop;
  const diff = Math.abs(toScrollTop - el.scrollTop);
  const forward = toScrollTop > el.scrollTop;
  start = now();
  const update = () => {
    if (!animations[currentId]) {
      delete animations[currentId];
      return;
    }
    const t = now();
    const offset = diff * Math.min(1, (t - start) / lengthMs);
    if (forward) {
      el.scrollTop = startLocation + offset;
    } else {
      el.scrollTop = startLocation - offset;
    }
    if (t - start < lengthMs) {
      requestAnimationFrame(update);
    }
  };
  requestAnimationFrame(update);
};

const shiftFocus = (horizontal, nextFocusableElement) => {
  if (!nextFocusableElement) {
    return;
  }
  const rect = nextFocusableElement.getBoundingClientRect();
  if (horizontal) {
    // find h scroll container
    const hScrollContainer = nextFocusableElement.parentElement;
    let diff = 0;
    if (rect.right > hScrollContainer.clientWidth) {
      diff = rect.right - hScrollContainer.clientWidth - 108;
    } else if (rect.left < 108) {
      diff = rect.left - 108;
    }
    if (diff !== 0) {
      const newScrollLeft = hScrollContainer.scrollLeft + diff;
      updateTargetScrollLeft(hScrollContainer, newScrollLeft, 200);
    }
  } else {
    // find v scroll container
    const vScrollContainer = nextFocusableElement.parentElement.parentElement;
    let diff = 0;
    if (rect.bottom > vScrollContainer.clientHeight) {
      diff = rect.bottom - vScrollContainer.clientHeight - 108;
    } else if (rect.top < 108) {
      diff = rect.top - 108;
    }
    if (diff !== 0) {
      const newScrollTop = vScrollContainer.scrollTop + diff;
      updateTargetScrollTop(vScrollContainer, newScrollTop, 200);
    }
  }
  nextFocusableElement.focus();
};


let eventIndex = 0;
const eventReplayDelay = 25;
const playSwipePointerUp = () => {
  window.dispatchEvent(
    new PointerEvent('pointerup', {
      pointerType: 'touchpad',
      screenX: swipeEvents[swipeEvents.length - 1][0],
      screenY: swipeEvents[swipeEvents.length - 1][1]})
  );
};
const playSwipePointerMove = () => {
  window.dispatchEvent(
    new PointerEvent('pointermove', {
      pointerType: 'touchpad',
      screenX: swipeEvents[eventIndex][0],
      screenY: swipeEvents[eventIndex][1]})
  );
  eventIndex++;
  if (eventIndex < swipeEvents.length) {
    setTimeout(playSwipePointerMove, eventReplayDelay);
    return;
  }
  setTimeout(playSwipePointerUp, eventReplayDelay);
}
const playSwipePointerDown = () => {
  eventIndex = 0;
  window.dispatchEvent(
    new PointerEvent('pointerdown', {
      pointerType: 'touchpad',
      screenX: swipeEvents[0][0],
      screenY: swipeEvents[0][1]})
  );
  setTimeout(playSwipePointerMove, eventReplayDelay);
};

const playJogPointerUp = () => {
  window.dispatchEvent(
    new PointerEvent('pointerup', {
      pointerType: 'touchpad',
      screenX: jogEvents[jogEvents.length - 1][0],
      screenY: jogEvents[jogEvents.length - 1][1]})
  );
};
const playJogPointerMove = () => {
  window.dispatchEvent(
    new PointerEvent('pointermove', {
      pointerType: 'touchpad',
      screenX: jogEvents[eventIndex][0],
      screenY: jogEvents[eventIndex][1]})
  );
  eventIndex++;
  if (eventIndex < jogEvents.length) {
    setTimeout(playJogPointerMove, eventReplayDelay);
    return;
  }
  setTimeout(playJogPointerUp, eventReplayDelay);
}
const playJogPointerDown = () => {
  eventIndex = 0;
  window.dispatchEvent(
    new PointerEvent('pointerdown', {
      pointerType: 'touchpad',
      screenX: jogEvents[0][0],
      screenY: jogEvents[0][1]})
  );
  setTimeout(playJogPointerMove, eventReplayDelay);
};

let swipeIndex = -1;
const swipes = {swipeHorizontalEndToEnd, swipeHorizontalMiddleToEnd, swipeVerticalEndToEnd, swipeVerticalMiddleToEnd};

window.addEventListener('keydown', e => {
  if (e.key === 'Esc' || e.key === 'Escape') {
    e.preventDefault();
    window.close();
    return;
  }
  if (e.key === 'j') {
    e.preventDefault();
    playJogPointerDown();
    return;
  }
  if (e.key === 's') {
    e.preventDefault();
    swipeIndex++;
    if (swipeIndex > 3) {
      swipeIndex = 0;
    }
    const key = Object.keys(swipes)[swipeIndex];
    swipeEvents = swipes[key].slice();
    playSwipePointerDown();
    return;
  }


  let nextFocusableElement = null;
  let inline = null;
  let horizontal = false;
  if (e.key === 'ArrowRight') {
    nextFocusableElement = getElementToRight(document.activeElement);
    horizontal = true;
  }
  if (e.key === 'ArrowLeft') {
    nextFocusableElement = getElementToLeft(document.activeElement);
    horizontal = true;
  }
  if (e.key === 'ArrowUp') {
    nextFocusableElement = getElementAbove(document.activeElement);
  }
  if (e.key === 'ArrowDown') {
    nextFocusableElement = getElementBelow(document.activeElement);
  }
  if (nextFocusableElement) {
    e.preventDefault();
    shiftFocus(horizontal, nextFocusableElement);
  }
});

let gesturing = false;
let gestureEvents = [];
let jogging = false;
let totalRadialDist = 0;
let swiping = false;
let deltaX = 0;
let deltaY = 0;
let shelfShift = [0, 0];

const getRadius = ([x, y]) => Math.sqrt(x * x + y * y);
const getRadian = ([x, y]) => {
  const r = getRadius([x, y]);
  return Math.atan2(y / r, x / r);
};

const getLine = ([x1, y1], [x2, y2]) => {
  const m = (y2 - y1) / (x2 - x1);
  const b = y1 - m * x1;
  return [m, b];
};

const distPointToLine = ([m, b]) => {
  const d = Math.sqrt(m * m + 1);
  return ([x, y]) => {
    return (m * x - y + b) / d;
  };
};

const largestDistanceToLine = pts => {
  const line = getLine(pts[0], pts[pts.length - 1]);
  const p2l = distPointToLine(line);
  return Math.max(...pts.map(p2l));
};

const radialDist = (rad1, rad2) => {
  const dist = Math.abs(rad1 - rad2);
  return dist < Math.PI ? dist : 2 * Math.PI - dist;
}

const isClockwise = (rad1, rad2) => {
  const dist = Math.abs(rad1 - rad2);
  if (dist < Math.PI) {
    return rad1 > rad2;
  }
  return rad2 > rad1;
};

const computeShelfShift = (deltaX, deltaY) => {
  const left = deltaX < 0 ? -1 : 1;
  const down = deltaY < 0 ? -1 : 1;
  return [left * Math.floor(Math.abs(deltaX) / .5), down * Math.floor(Math.abs(deltaY) / .5)];
};

const computeShelfShiftRadial = rad => {
  const unsignedRad = Math.abs(rad / (2 * Math.PI));
  const direction = rad > 0 ? 1 : -1;
  return [direction * Math.floor(unsignedRad * 6), 0];
};

outerRadiusThreshold = .5
distToLineThreshold = .1
radialDistThreshold = .4
const getGesture = pts => {
  const rs = pts.map(getRadius);
  if (Math.min(...rs) < outerRadiusThreshold || Math.max(...rs) > 1) {
    return 'swipe';
  }
  const distToLine = largestDistanceToLine(pts);
  if (distToLine > distToLineThreshold) {
    return 'jog';
  }
  const rd = radialDist(getRadian(pts[0]), getRadian(pts[pts.length - 1]));
  if (rd > radialDistThreshold) {
    return 'jog';
  }
  return 'unk';
};

const moveFocus = updateShift => {
  if (updateShift[0] === 0 && updateShift[1] === 0) {
    return;
  }
  if (updateShift[0] > 0) {
    let i = updateShift[0];
    let elementToFocus = null;
    let nextFocusableElement = document.activeElement;
    while (i !== 0 && nextFocusableElement) {
      i--;
      nextFocusableElement = getElementToRight(nextFocusableElement);
      if (nextFocusableElement) {
        elementToFocus = nextFocusableElement;
      }
    }
    shiftFocus(/*horizontal=*/true, elementToFocus);
  } else if (updateShift[0] < 0) {
    let i = updateShift[0];
    let elementToFocus = null;
    let nextFocusableElement = document.activeElement;
    while (i !== 0 && nextFocusableElement) {
      i++;
      nextFocusableElement = getElementToLeft(nextFocusableElement);
      if (nextFocusableElement) {
        elementToFocus = nextFocusableElement;
      }
    }
    shiftFocus(/*horizontal=*/true, elementToFocus);
  } else if (updateShift[1] > 0) {
    let i = updateShift[1];
    let elementToFocus = null;
    let nextFocusableElement = document.activeElement;
    while (i !== 0 && nextFocusableElement) {
      i--;
      nextFocusableElement = getElementAbove(nextFocusableElement);
      if (nextFocusableElement) {
        elementToFocus = nextFocusableElement;
      }
    }
    shiftFocus(/*horizontal=*/false, elementToFocus);
  } else if (updateShift[1] < 0) {
    let i = updateShift[1];
    let elementToFocus = null;
    let nextFocusableElement = document.activeElement;
    while (i !== 0 && nextFocusableElement) {
      i++;
      nextFocusableElement = getElementBelow(nextFocusableElement);
      if (nextFocusableElement) {
        elementToFocus = nextFocusableElement;
      }
    }
    shiftFocus(/*horizontal=*/false, elementToFocus);
  }
};

let pastShifts = [];
window.addEventListener('pointermove', e => {
  if (e.pointerType === 'touchpad') {
    // flip y, top of touchpad is sent as y=-1.
    const currentPt = [e.screenX, -e.screenY];
    gestureEvents.push(currentPt);
    if (!jogging && !swiping) {
      const gestureType = getGesture(gestureEvents);
      if (gestureType === 'unk') {
        return;
      }
      if (gestureType === 'jog') {
        gestureEvents = [gestureEvents[0], currentPt];
        jogging = true;
      }
      if (gestureType === 'swipe') {
        swiping = true;
      }
    }
    if (jogging && getRadius(currentPt) < outerRadiusThreshold) {
      gestureEvents = [];
      return;
    }
    if (jogging && gestureEvents.length >= 2) {
      const prev = getRadian(gestureEvents[gestureEvents.length - 2]);
      const cur = getRadian(gestureEvents[gestureEvents.length - 1]);
      const newRadialDist = radialDist(prev, cur);
      const oldShelfShift = computeShelfShiftRadial(totalRadialDist);
      if (isClockwise(prev, cur)) {
        totalRadialDist += newRadialDist;
      } else {
        totalRadialDist -= newRadialDist;
      }
      const newShelfShift = computeShelfShiftRadial(totalRadialDist);
      const updateShift = [newShelfShift[0] - oldShelfShift[0], newShelfShift[1] - oldShelfShift[1]];
      moveFocus(updateShift);
      shelfShift = newShelfShift;
      return;
    }
    if (swiping) {
      const oldShelfShift = computeShelfShift(deltaX, deltaY);
      deltaX = currentPt[0] - gestureEvents[0][0];
      deltaY = currentPt[1] - gestureEvents[0][1];
      const newShelfShift = computeShelfShift(deltaX, deltaY);
      const updateShift = [newShelfShift[0] - oldShelfShift[0], newShelfShift[1] - oldShelfShift[1]];
      moveFocus(updateShift);
      shelfShift = newShelfShift;
      return;
    }
  }
});

window.addEventListener('pointerdown', e => {
  if (e.pointerType === 'touchpad') {
  }
});

window.addEventListener('pointerup', e => {
  if (e.pointerType === 'touchpad') {
    gestureEvents = [];
    jogging = false;
    swiping = false;
    shelfShift = [0, 0];
    pastShifts = [];
    totalRadialDist = 0;
    deltaX = 0;
    deltaY = 0;
  }
});

  </script>
</html>
